import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter_gemini/flutter_gemini.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:yumm_ai/core/api/api_client.dart';
import 'package:yumm_ai/core/constants/propmpts.dart';
import 'package:yumm_ai/core/enums/cooking_expertise.dart';
import 'package:yumm_ai/core/enums/meals.dart';
import 'package:yumm_ai/core/services/imagen_service.dart';
import 'package:yumm_ai/features/chef/data/datasource/recipe_remote_datasource.dart';
import 'package:yumm_ai/features/chef/data/models/Ingrident_model.dart';
import 'package:yumm_ai/features/chef/data/models/recipe_model.dart';
import 'package:yumm_ai/features/chef/data/repositories/recipe_repository_impl.dart';
import 'package:yumm_ai/features/chef/domain/repositories/recipe_repository.dart';

// Providers
final recipeRemoteDataSourceProvider = Provider<RecipeRemoteDataSource>((ref) {
  return RecipeRemoteDataSourceImpl(ref.read(apiClientProvider));
});

final recipeRepositoryProvider = Provider<RecipeRepository>((ref) {
  return RecipeRepositoryImpl(ref.read(recipeRemoteDataSourceProvider));
});

final imagenServiceProvider = Provider<ImagenService>((ref) {
  return ImagenService();
});

final pantryChefViewModelProvider =
    NotifierProvider<PantryChefViewModel, PantryChefState>(
      PantryChefViewModel.new,
    );

// State
class PantryChefState {
  final bool isLoading;
  final String? loadingMessage;
  final RecipeModel? generatedRecipe;
  final String? error;

  PantryChefState({
    this.isLoading = false,
    this.loadingMessage,
    this.generatedRecipe,
    this.error,
  });

  PantryChefState copyWith({
    bool? isLoading,
    String? loadingMessage,
    RecipeModel? generatedRecipe,
    String? error,
  }) {
    return PantryChefState(
      isLoading: isLoading ?? this.isLoading,
      loadingMessage: loadingMessage ?? this.loadingMessage,
      generatedRecipe: generatedRecipe ?? this.generatedRecipe,
      error: error, // Clear error if not provided
    );
  }
}

// ViewModel
class PantryChefViewModel extends Notifier<PantryChefState> {
  late final RecipeRepository _recipeRepository;
  late final ImagenService _imagenService;

  @override
  PantryChefState build() {
    _recipeRepository = ref.read(recipeRepositoryProvider);
    _imagenService = ref.read(imagenServiceProvider);
    return PantryChefState();
  }

  Future<void> generateMeal({
    required List<IngredientModel> ingredients,
    required Meal mealType,
    required Duration availableTime,
    required CookingExpertise expertise,
    required String currentUserId,
  }) async {
    try {
      state = state.copyWith(
        isLoading: true,
        loadingMessage: "Crafting your recipe with Gemini...",
        error: null,
      );

      // 1. Generate text recipe with Gemini
      final prompt = await Propmpts().getPantryChefMealPrompt(
        availableIngridents: ingredients,
        mealType: mealType,
        availableTime: availableTime,
        cookingExperties: expertise,
      );

      final response = await Gemini.instance.prompt(parts: [Part.text(prompt)]);

      if (response?.output == null) {
        throw Exception("Failed to generate recipe text");
      }

      // Parse JSON from Gemini response
      String jsonString = response!.output!;
      // Clean up markdown code blocks if present
      if (jsonString.contains('```json')) {
        jsonString = jsonString.replaceAll('```json', '').replaceAll('```', '');
      } else if (jsonString.contains('```')) {
        jsonString = jsonString.replaceAll('```', '');
      }

      final Map<String, dynamic> jsonMap = jsonDecode(jsonString);

      // Create partial model from AI response
      // We use fromAiJson to map ingredient names back to original IDs/images if needed
      // But for simplicity, we first just get the structure
      var tempRecipe = RecipeModel.fromAiJson(jsonMap, ingredients);

      // Ensure generatedBy is set
      // (Since fromAiJson might leave it empty if not in JSON, which it isn't)
      // We will reconstruct it properly

      state = state.copyWith(
        loadingMessage: "Generating mouth-watering images with Imagen 3.0...",
      );

      // 2. Generate Images (Client-side)
      final generatedImages = await _imagenService.generateRecipeImages(
        recipeName: tempRecipe.recipeName,
        description: tempRecipe.description,
        numberOfImages: 2,
      );

      state = state.copyWith(loadingMessage: "Saving your masterpiece...");

      // 3. Upload Images to Server
      // We need a temporary recipeId if one wasn't generated by AI,
      // but the prompt says "<generate a unique UUID>".
      // Assuming AI follows instruction, we use that ID.
      final String recipeId = tempRecipe.recipeId;

      List<String> imageUrls = [];
      if (generatedImages.isNotEmpty) {
        imageUrls = await _recipeRepository.uploadRecipeImages(
          recipeId: recipeId,
          images: generatedImages,
        );
      }

      // 4. Save Recipe to Server (with image URLs and user ID)
      final finalRecipe = RecipeModel(
        recipeId: recipeId,
        generatedBy: currentUserId, // Set the current user ID
        recipeName: tempRecipe.recipeName,
        ingredients: tempRecipe.ingredients,
        steps: tempRecipe.steps,
        initialPreparation: tempRecipe.initialPreparation,
        kitchenTools: tempRecipe.kitchenTools,
        experienceLevel: tempRecipe.experienceLevel,
        estCookingTime: tempRecipe.estCookingTime,
        description: tempRecipe.description,
        mealType: tempRecipe.mealType,
        cuisine: tempRecipe.cuisine,
        calorie: tempRecipe.calorie,
        images: imageUrls, // Add the uploaded URLs
        nutrition: tempRecipe.nutrition,
        servings: tempRecipe.servings,
        likes: [],
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await _recipeRepository.saveRecipe(finalRecipe);

      state = state.copyWith(
        isLoading: false,
        generatedRecipe: finalRecipe,
        loadingMessage: null,
      );
    } catch (e) {
      debugPrint("Error in generateMeal: $e");
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
        loadingMessage: null,
      );
    }
  }
}
